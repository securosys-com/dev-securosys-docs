"use strict";(self.webpackChunksecurosys_docs=self.webpackChunksecurosys_docs||[]).push([[3300],{28453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>o});var t=n(96540);const i={},a=t.createContext(i);function r(e){const s=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:s},e.children)}},54379:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>r,metadata:()=>t,toc:()=>m});const t=JSON.parse('{"id":"Use-Cases/ckm_key_split","title":"PKCS#11 - Key split mechanism","description":"This features of the Primus PKCS#11 provider is a vendor defined","source":"@site/pkcs/Use-Cases/ckm_key_split.md","sourceDirName":"Use-Cases","slug":"/Use-Cases/ckm_key_split","permalink":"/pkcs/Use-Cases/ckm_key_split","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1741162132000,"frontMatter":{"title":"PKCS#11 - Key split mechanism","sidebar_label":"Key split mechanism"},"sidebar":"tutorialSidebar","previous":{"title":"PKCS#11 - Wrapper","permalink":"/pkcs/Use-Cases/PKCS11-Wrapper/sample-wrapper"},"next":{"title":"Building Own Applications","permalink":"/pkcs/Use-Cases/own_application"}}');var i=n(74848),a=n(28453);const r={title:"PKCS#11 - Key split mechanism",sidebar_label:"Key split mechanism"},o="Key split mechanism",c={},m=[];function p(e){const s={admonition:"admonition",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"key-split-mechanism",children:"Key split mechanism"})}),"\n",(0,i.jsx)(s.admonition,{type:"info",children:(0,i.jsx)(s.p,{children:"This features of the Primus PKCS#11 provider is a vendor defined\nextension and is not part of the standard PKCS#11 suite."})}),"\n",(0,i.jsx)(s.p,{children:"CKM_KEY_SPLIT is a mechanism for C_DeriveKey which allows to create\na new key from a substring of a GENERIC_SECRET value. The base key\nmust be marked as CKA_COPYABLE. The start of the substring must be\nprovided as the mechanism parameter."}),"\n",(0,i.jsx)(s.p,{children:'The following example creates a 256-bit AES key from a 32-byte substring\nof "inputKey" which is a GENERIC_SECRET.'}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-C",children:"// Set mechanism parameters.\nCK_MECHANISM mechanism;\nmemset(&mechanism, 0, sizeof(CK_MECHANISM));\nmechanism.mechanism = CKM_KEY_SPLIT;\n\n// Pass the substring length as mechanism parameter.\nuint32_t byteOffset = 16;\nmechanism.pParameter = (void*)&byteOffset;\nmechanism.ulParameterLen = sizeof(byteOffset);\n\n// Define the byte length of the substring.\nCK_ULONG derivedSecretLen = 32;\n\n// Define the type of the new key.\nCK_KEY_TYPE keyType = CKK_AES;\nCK_OBJECT_CLASS secretKeyClass = CKO_SECRET_KEY;\n\nCK_BBOOL bFalse = CK_FALSE;\nCK_BBOOL bTrue = CK_TRUE;\nCK_ATTRIBUTE keyAttributes[] = {\n        { CKA_TOKEN, &bFalse, sizeof(CK_BBOOL) },\n        { CKA_PRIVATE, &bTrue, sizeof(CK_BBOOL) },\n        { CKA_ENCRYPT, &bTrue, sizeof(CK_BBOOL) },\n        { CKA_KEY_TYPE, &keyType, sizeof(keyType) },\n        { CKA_VALUE_LEN, &derivedSecretLen, sizeof(derivedSecretLen) },\n        { CKA_CLASS, &secretKeyClass, sizeof(secretKeyClass) },\n};\n\nrv = C_DeriveKey(\n        sessionHandle,\n        &mechanism,\n        inputKey,\n        keyAttributes,\n        sizeof(keyAttributes) / sizeof(CK_ATTRIBUTE),\n        &newKey);\n"})})]})}function l(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);