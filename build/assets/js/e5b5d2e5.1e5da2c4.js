"use strict";(self.webpackChunksecurosys_docs=self.webpackChunksecurosys_docs||[]).push([[43886],{28453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>o});var r=n(96540);const t={},a=r.createContext(t);function s(e){const i=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:i},e.children)}},64388:(e,i,n)=>{n.d(i,{A:()=>r});const r=n.p+"assets/files/KeySignatureAndVerificationSample-d71062974197804350a43ba4d7ced18b.java"},87339:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Tutorials/SignVerify","title":"Create a Signature Key in an HSM with JCE/JCA","description":"Creating a signature key with Java Cryptography Extension (JCE) and Java Cryptography Architecture (JCA) with Securosys Hardware Security Modules.","source":"@site/jce/Tutorials/SignVerify.md","sourceDirName":"Tutorials","slug":"/Tutorials/SignVerify","permalink":"/jce/Tutorials/SignVerify","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1741162132000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Create a Signature Key in an HSM with JCE/JCA","sidebar_label":"Sign & Verify","description":"Creating a signature key with Java Cryptography Extension (JCE) and Java Cryptography Architecture (JCA) with Securosys Hardware Security Modules.","keywords":["hsm","cloud hsm"]},"sidebar":"tutorialSidebar","previous":{"title":"Login Sample","permalink":"/jce/Tutorials/LoginSample"},"next":{"title":"Key Attributes","permalink":"/jce/Tutorials/KeyAttributes"}}');var t=n(74848),a=n(28453);const s={sidebar_position:1,title:"Create a Signature Key in an HSM with JCE/JCA",sidebar_label:"Sign & Verify",description:"Creating a signature key with Java Cryptography Extension (JCE) and Java Cryptography Architecture (JCA) with Securosys Hardware Security Modules.",keywords:["hsm","cloud hsm"]},o="Sign & Verify",c={},l=[{value:"Breakdown",id:"breakdown",level:2}];function d(e){const i={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"sign--verify",children:"Sign & Verify"})}),"\n",(0,t.jsx)(i.p,{children:"This sample code demonstrates the end-to-end process of creating a signature key in an HSM, signing a payload, and verifying the signature using the corresponding public key. The code is well-commented to provide clarity on each step."}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(64388).A+"",children:"KeySignatureAndVerificationSample.java"})}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"breakdown",children:"Breakdown"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'/*\n * Copyright (C) 2019, Securosys SA\n */\n\nimport com.securosys.primus.jce.PrimusName;\nimport com.securosys.primus.jce.PrimusProvider;\n\nimport java.security.KeyPairGenerator;\nimport java.security.KeyStore;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.security.cert.Certificate;\nimport java.util.Arrays;\nimport java.util.UUID;\n\n/**\n * Sample code showing how to create a key, perform a signature operation with it and verify the signature.\n * The sample goes through the following steps:\n * 1) Logs into the HSM\n * 2) Creates a signature key in the HSM\n * 3) Retrieves the key pair from the HSM\n * 4) Requests the HSM to sign a payload\n * 5) Verifies the signature using the public key\n */\npublic class KeySignatureAndVerificationSample {\n\n    public static void main(final String... args) throws Exception {\n\n        // 1 -- HSM AND PROVIDER CONFIGURATION\n\n        // HSM configuration\n        PrimusHelper.setup(args);\n\n        // 2 -- CREATE A SIGNATURE KEY\n\n        final int keySize = 2048; // keySize (in case of RSA)\n\n        System.out.println("creating RSA key pair of " + keySize + " bits ...");\n\n        // create an RSA key, in this case with randomly set name\n        final String signKeyName = UUID.randomUUID().toString();\n        PrimusName.generate(\n            KeyPairGenerator.getInstance("RSA", PrimusProvider.getProviderName()), // algorithm specification\n            keySize, // keySize\n            new Certificate[0], // necessary to be able to get public key from key store\n            signKeyName // name to look the key up with from the key store\n        );\n\n        System.out.println("Signature key created");\n\n        // 3 -- RETRIEVE THE SIGNATURE KEY\n\n        final KeyStore primusKeyStore = KeyStore.getInstance(PrimusProvider.getKeyStoreTypeName(), PrimusProvider.getProviderName());\n        primusKeyStore.load(null);\n\n        // retrieve private key (HSM pointer), and public key for local verification\n        final PrivateKey signKey = (PrivateKey)primusKeyStore.getKey(signKeyName, null);\n        final PublicKey signKeyPublic = primusKeyStore.getCertificate(signKeyName).getPublicKey();\n\n        // 4 -- SIGN A PAYLOAD\n\n        // random payload - in real life it would be e.g. a cryptocurrency transaction\n        final int payloadSize = 250;\n        final byte[] payload = new byte[payloadSize];\n        Arrays.fill(payload, (byte)\'A\');\n\n        final String signAlgorithm = "SHA256withRSA";\n\n        // request the payload signature\n        final Signature signature = Signature.getInstance(signAlgorithm, PrimusProvider.getProviderName());\n        signature.initSign(signKey);\n        signature.update(payload);\n        final byte[] sig = signature.sign();\n        System.out.println("Signature successful");\n\n        // 5 -- VERIFY THE SIGNATURE\n\n        final Signature localVerifier = Signature.getInstance(signAlgorithm);\n        localVerifier.initVerify(signKeyPublic);\n        localVerifier.update(payload);\n        final boolean signSignatureOk = localVerifier.verify(sig);\n        System.out.println("Sign signature is " + (signSignatureOk ? "OK" : "NOT OK"));\n\n    }\n\n}\n'})}),"\n",(0,t.jsx)(i.p,{children:"Explanation:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"HSM and Provider Configuration:"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["The Primus HSM and provider are configured using ",(0,t.jsx)(i.code,{children:"PrimusHelper.setup(args)"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Create a Signature Key:"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"An RSA key pair is generated with a specified key size."}),"\n",(0,t.jsxs)(i.li,{children:["The key pair is assigned a unique name (",(0,t.jsx)(i.code,{children:"signKeyName"}),") using ",(0,t.jsx)(i.code,{children:"PrimusName.generate"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Retrieve the Signature Key:"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["The key pair is retrieved from the HSM using the key name (",(0,t.jsx)(i.code,{children:"signKeyName"}),")."]}),"\n",(0,t.jsxs)(i.li,{children:["The private key (",(0,t.jsx)(i.code,{children:"signKey"}),") and the corresponding public key (",(0,t.jsx)(i.code,{children:"signKeyPublic"}),") are obtained from the key store."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Sign a Payload:"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["A random payload of a specified size (",(0,t.jsx)(i.code,{children:"payloadSize"}),") is created."]}),"\n",(0,t.jsxs)(i.li,{children:["The payload is signed using the private key (",(0,t.jsx)(i.code,{children:"signKey"}),") with the specified signing algorithm (",(0,t.jsx)(i.code,{children:"SHA256withRSA"}),")."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Verify the Signature:"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["The signature is verified using the public key (",(0,t.jsx)(i.code,{children:"signKeyPublic"}),") and the same payload."]}),"\n",(0,t.jsx)(i.li,{children:"The result of the verification is printed, indicating whether the signature is valid."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.admonition,{title:"disclaimer",type:"note",children:[(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Private Key Operations within HSM"})}),(0,t.jsx)(i.p,{children:"This sample code includes operations involving private keys, such as signing payloads, which are exclusively executed within the confines of the Hardware Security Module (HSM). The HSM is a secure and isolated environment designed to safeguard cryptographic operations."}),(0,t.jsx)(i.p,{children:"It is crucial to emphasize that verification operations, specifically those utilizing the corresponding public key, are intended to be performed outside the HSM on the client side. The verification process ensures the integrity and authenticity of the signed data, and this separation is fundamental to maintaining the security principles of cryptographic systems."}),(0,t.jsx)(i.p,{children:"Users should exercise caution and adhere to security best practices when handling cryptographic keys, ensuring that private key operations are consistently confined to the secure environment of the HSM, while public key verification occurs in trusted client-side environments."}),(0,t.jsx)(i.p,{children:"This code serves as a sample and should be adapted and utilized with a thorough understanding of cryptographic principles and secure coding practices."})]})]})}function u(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);